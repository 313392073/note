var 声明一个变量 初始化一个值 存在变量
let 声明一个块作用域的局部变量 
const 声明一个只读常量  不可以通过赋值改变其值

变量作用域：
函数外的变量  全局变量 
函数内部声明的变量 局部变量 只在该函数内部访问

ECMAscript6：语句块作用域
语句块中声明的变量将成为语句块所在代码段的局部变量

变量声明提升：
可以引用稍后声明的变量而不会发生异常
 变量感觉上是被提升或移到了所有函数和语句之前  然而提升后的变量将返回undefined  
 所以在使用或引用某个变量之后进行声明和初始化操作  这个被提升的引用仍将得到undefined值

函数提升：
对于函数 只有函数声明会被提升到顶部   而不包括函数表达式
//函数声明
function foo() {}
函数表达式  表达式定义的函数 称之为匿名函数 匿名函数没有函数提升


数据类型和结构

六种原始数据类型：
boolean :
null：
undefined：变量未定义时的属性
Number 数字
String:字符串
Symbol(ECMAscript6中新添加的类型)：一种数据类型 它的实例是唯一且不可改变的

以及Object对象

字面量：字面量是由语法表达式定义的常亮 或者是通过由一定字词组成的语词表达式定义的常亮

语句块：
大多数程序都使用语句块来给语句分组 语句的结构就更清晰明了了  使用{}来分组语句块
 语句块通常用于流程控制 如if for while 
 while(x<10) {x++;}  {x++;}就是语句块
 注意在ECMAScript6之前没有块作用域 如果在块的外部声明了一个变量
  然后在块中声明了一个相同变量名的变量 并赋予不同的值 那么程序执行中将会使用块中的值 
var x = 1;
{var x = 2}
alert(x) //2

对象操作语句:
for  in 语句迭代一个指定的变量去遍历这个对象的属性  每个属性 javascript执行指定的语句
for (variable in object) {statements}

数组(arrays)

for in 方式遍历数组的弊端：如果添加了通用属性或者方法 for in 语句还会返回除了数字索引外的自定义属性的名称
因此还是用带有数字索引的传统for循环来遍历数组会比较好

promises 对象 允许你对延时和异步操作流进行控制

状态：
pending进行中：初始的状态 即整在执行 不处于fulfilled 或rejected状态
fulilled已完成：成功的完成了操作
rejected已失败：失败 没有完成操作
settled已解决：promise

数组：
for of
for of语句在可迭代的对象上创建了一个循环(包括Array Map Set,参数对象(arguments))
对值得每一个独特的属性调用一个将被执行的自定义和语句挂钩的迭代
for(variable of object) {statement}

函数声明:由一系列的函数关键字组成：
function square(number) {
	return number * number;
} 

function myFunc(theObject) {
	theObject.make = 'Toyota';
}
var mycar = {make:'Honda',model:'Accord',year:1998};
var x,y;
myFunc(mycar) {
	y = mycar.make;
}

嵌套函数和闭包：
你可以再一个函数里面嵌套另外一个函数 嵌套函数对其容器函数是私有的 他自身也形成了一个闭包
一个闭包是一个可以自己拥有的独立的环境与变量的表达式(通常是函数)

既然嵌套函数是一个闭包 就意味着一个嵌套函数可以继承容器函数的参数和变量
换句话说 内部函数包含外部函数的作用域
总结：
	内部函数只可以在外部函数中访问
	内部函数形成了一个闭包；他可以访问外部函数的参数和变量
	但是外部函数却不能使用它的参数和变量

闭包：
javascript中最强大的特性之一 
javascript允许函数嵌套函数 并且内部函数可以访问定义在外部函数中的
所有变量和函数 以及外部函数能访问的所有变量和函数；
但是 外部函数却不能够访问定义在内部函数中变量和函数
这给内部函数的变量提供了一定的安全性 而且 当内部函数生存 周期大于外部函数时
由于内部函数可以访问外部函数的作用域  定义在外部函数的变量和函数的生存周期就会大于外部
函数本身 当内部函数以某一种方式被任何一个外部函数作用域访问时 一个闭包就产生了

对象：
一个对象是一个包含相关资料和功能的集体
通常有一些变量和函数组成 对象的属性和方法

[]括号表示法：
不仅可以动态的去设置对象成员的值 还可以动态设置成员的名字（括号里的可以是变量）
使用的是关联值得名字 不是向数组一样通过索引
对象也可以叫做关联数组 
对象做了字符串到值得映射
数组做了数字到值得映射


this:关键字this指向的是当前代码运行时的对象


面向对象：
对象可以包含相关的数据和代码 这些代表现实世界模型的一些信息或者功能或者它特有的一些行为 
对象数据（函数）可以有结构存储（封装）在对象内 （可以给一个特殊的名字来表示 有时候也叫作命名空间）
可以使它容易组织和访问 对象也通常用于存储数据 

类可以描述一个对象 类并不完全是一个对象 更像是一个定义对象特质的模板

我们能够基于类创建出一些对象实例 一些拥有class中属性和方法的对象
当一个对象实例需要从类中创建出来 类的构造函数就会运行来创建这个实例
这种创建对象实例的过程 实例化

构造函数：提供了创建你所需对象的有效方法  将对象的数据和特征函数按需联结致相应的对象

用new关键字告诉浏览器 我们想要创建一个新的对象实例

原型：每一个对象拥有一个原型对象  对象以其原型为模板 从原型继承方法和属性 
原型也可以拥有原型 并从中继承方法和属性 （原型链） 
作用：解释了一个对象会拥有定义在其他对象中的属性和方法

准确的说：这些属性和方法定义在Object的构造器函数之上  而不是对象实例本身

传统的面向对象：
先定义类  此后创建的对象实例 类中定义的所有属性和方法都被复制到实例中 

javascript中：
在对象实例和他的构造器之间建立一个连接（作为原型链中的一节） 以后通过
上溯原型链  在构造器中找到这些属性和方法 
